package main

import (
	"bytes"
	"database/sql"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"strings"

	"go/format"

	// Pulling in the mysql driver
	_ "github.com/go-sql-driver/mysql"
)

var (
	database = flag.String("db", "", "The Database to connect to")
	host     = flag.String("host", "", "The Host to connect to. Defaults to localhost")
	username = flag.String("user", "", "The User to connect with")
	password = flag.String("pass", "", "The Password to use")
	outfile  = flag.String("out", "statements.go", "The file the prepared statements will be written to")
	pkg      = flag.String("pkg", "statement", "The package name the generated constants will be in")
)

// Table represents a SQL table
type Table struct {
	name        string
	columns     []*Column // The columns in this table
	columnNames []string
}

// Column represents a SQL column
type Column struct {
	name     string // The name of the column
	ctype    string
	null     string
	key      string
	cdefault string
	extra    string
}

// Generator generates the file
type Generator struct {
	buf bytes.Buffer
}

func main() {
	log.SetPrefix("ps-generator: ")
	flag.Parse()

	db, err := sql.Open("mysql", fmt.Sprintf("%s:%s@%s/%s", *username, *password, *host, *database))
	defer db.Close()
	if err != nil {
		log.Panicf("Failed to open the database!\n\t%s", err)
	}

	tables := generateTableMetadata(db)

	generator := Generator{}
	generator.generate(tables)

	src := generator.format()

	err = ioutil.WriteFile(*outfile, src, 0644)
	if err != nil {
		log.Fatalf("Writing output failed! %s", err)
	}
}

func generateTableMetadata(db *sql.DB) []*Table {
	rows, err := db.Query("SHOW TABLES")
	if err != nil {
		log.Panicf("Failed to query the database!\n\t%s", err)
	}

	var tables []*Table
	for rows.Next() {
		table := new(Table)
		err := rows.Scan(&table.name)

		if err != nil {
			log.Panicf("Failed to scan column!\n\t%s", err)
		}

		tables = append(tables, table)
	}
	rows.Close()

	for _, table := range tables {
		rows, err := db.Query(fmt.Sprintf("desc `%s`;", table.name))

		if err != nil {
			log.Panicf("Failed to describe table!\n\t%s", err)
		}

		for rows.Next() {
			column := new(Column)
			var key, cdefault, extra sql.NullString

			err := rows.Scan(&column.name, &column.ctype, &column.null, &key, &cdefault, &extra)

			if key.Valid {
				column.key = key.String
			}

			if cdefault.Valid {
				column.cdefault = cdefault.String
			}

			if extra.Valid {
				column.extra = extra.String
			}

			if err != nil {
				log.Panicf("Failed to scan column!\n\t%s", err)
			}

			table.columns = append(table.columns, column)
			table.columnNames = append(table.columnNames, column.name)
		}

		rows.Close()
	}

	return tables
}

func (g *Generator) generate(tables []*Table) {
	g.printf("// generated by ps-generator; DO NOT EDIT\n")
	g.printf("\n")
	g.printf("package %s", *pkg)
	g.printf("\n")

	for _, table := range tables {
		g.processTable(table)
	}
}

func (g *Generator) processTable(table *Table) {
	/*
	  Should output something like this:
	  const (
	    TABLENAME_LIST = ``
	    TABLENAME_BY_ID = ``
	    TABLENAME_INSERT = ``
	    TABLENAME_UPDATE = ``
	    TABLENAME_DELETE = ``
	  )
	*/

	g.printf("// Constants for the %s table\n", table.name)
	g.printf("const (\n")

	g.printf("%s_List = `%s`\n", table.name, g.list(table))
	g.printf("%s_ByID = `%s`\n", table.name, g.byID(table))
	g.printf("%s_Insert = `%s`\n", table.name, g.insert(table))
	g.printf("%s_Update = `%s`\n", table.name, g.update(table))
	g.printf("%s_Delete = `%s`\n", table.name, g.delete(table))

	g.printf(")\n\n")
}

func (g *Generator) list(table *Table) string {
	return fmt.Sprintf("select %s from %s", strings.Join(table.columnNames, ", "), table.name)
}

func (g *Generator) byID(table *Table) string {
	idColumn := "id" // sensible default...

	for _, column := range table.columns {
		if strings.EqualFold(column.key, "PRI") {
			idColumn = column.name
			break // we only support single column primary keys right now
		}
	}

	return fmt.Sprintf("select %s from %s where %s = ?", strings.Join(table.columnNames, ", "), table.name, idColumn)
}

func (g *Generator) insert(table *Table) string {
	var namesCopy []string

	for _, column := range table.columns {
		if !strings.EqualFold(column.key, "PRI") {
			namesCopy = append(namesCopy, column.name)
		}
	}

	return fmt.Sprintf("insert into %s (%s) values (%s?)", table.name, strings.Join(namesCopy, ", "), strings.Repeat("?, ", len(namesCopy)-1))
}

func (g *Generator) update(table *Table) string {
	var names []string
	idColumn := "id"

	for _, column := range table.columns {
		if !strings.EqualFold(column.key, "PRI") {
			names = append(names, fmt.Sprintf("%s = ?", column.name))
		} else {
			idColumn = column.name
		}
	}

	return fmt.Sprintf("update %s set %s where %s = ?", table.name, strings.Join(names, ", "), idColumn)
}

func (g *Generator) delete(table *Table) string {
	idColumn := "id" // sensible default...

	for _, column := range table.columns {
		if strings.EqualFold(column.key, "PRI") {
			idColumn = column.name
			break // we only support single column primary keys right now
		}
	}

	return fmt.Sprintf("delete from %s where %s = ?", table.name, idColumn)
}

func (g *Generator) printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

// format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}
